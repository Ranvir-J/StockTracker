// --- template _header.gotpl ---
// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package db

import (
	"context"
	"fmt"
	"os"
	"slices"
	"testing"

	// no-op import for go modules
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"

	"github.com/steebchen/prisma-client-go/engine"
	"github.com/steebchen/prisma-client-go/engine/mock"
	"github.com/steebchen/prisma-client-go/runtime/builder"
	"github.com/steebchen/prisma-client-go/runtime/lifecycle"
	"github.com/steebchen/prisma-client-go/runtime/raw"
	"github.com/steebchen/prisma-client-go/runtime/transaction"
	"github.com/steebchen/prisma-client-go/runtime/types"
	rawmodels "github.com/steebchen/prisma-client-go/runtime/types/raw"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

type PrismaTransaction = transaction.Transaction

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type Boolean = bool
type String = string
type Int = int
type Float = float64

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

type RawString = rawmodels.String
type RawInt = rawmodels.Int
type RawFloat = rawmodels.Float
type RawBoolean = rawmodels.Boolean
type RawDateTime = rawmodels.DateTime
type RawJSON = rawmodels.JSON
type RawBytes = rawmodels.Bytes
type RawBigInt = rawmodels.BigInt
type RawDecimal = rawmodels.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template client.gotpl ---
const datasources = `[{"name":"db","provider":"postgresql","activeProvider":"postgresql","url":{"fromEnvVar":"DATABASE_URL","value":""},"config":null}]`

const schema = `datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator db {
  provider = "go run github.com/steebchen/prisma-client-go"
}

model Post {
  id       String @id @unique @db.VarChar(100)
  partnum  String @db.VarChar(100) // primary key
  quantity Int    @default(0)
  //userid String @unique @db.VarChar(12) 

  createdAt DateTime? @default(now()) @map("created_at") // can be null
  updatedAt DateTime? @updatedAt @map("updated_at") // can be null

  // title String @map("title") @db.VarChar(100)
  // published Boolean? @map("published") @default(false)
  // description String? @map("description") @db.VarChar(100)
}
`
const schemaDatasourceURL = ""
const schemaEnvVarName = "DATABASE_URL"

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = true

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//	client := db.NewClient()
//	if err := client.Prisma.Connect(); err != nil {
//	  handle(err)
//	}
//
//	defer func() {
//	  if err := client.Prisma.Disconnect(); err != nil {
//	    panic(fmt.Errorf("could not disconnect: %w", err))
//	  }
//	}()
func NewClient(options ...func(config *PrismaConfig)) *PrismaClient {
	var config PrismaConfig
	for _, option := range options {
		option(&config)
	}

	c := newClient()

	// use the schema connection url if set
	url := config.datasourceURL
	if url == "" {
		url = schemaDatasourceURL
		if url == "" {
			// if not, use the schema env var name
			url = os.Getenv(schemaEnvVarName)
			if url == "" {
				//panic("no connection string found")
				println("WARNING: env var which was defined in the Prisma schema is not set " + schemaEnvVarName)
			}
		}
	}

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets, datasources, url)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

type PrismaConfig struct {
	datasourceURL string
}

func WithDatasourceURL(url string) func(*PrismaConfig) {
	return func(config *PrismaConfig) {
		config.datasourceURL = url
	}
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.Post = postActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// Post provides access to CRUD methods.
	Post postActions
}

// --- template enums.gotpl ---

type TransactionIsolationLevel string

const (
	TransactionIsolationLevelReadUncommitted TransactionIsolationLevel = "ReadUncommitted"
	TransactionIsolationLevelReadCommitted   TransactionIsolationLevel = "ReadCommitted"
	TransactionIsolationLevelRepeatableRead  TransactionIsolationLevel = "RepeatableRead"
	TransactionIsolationLevelSerializable    TransactionIsolationLevel = "Serializable"
)

type PostScalarFieldEnum string

const (
	PostScalarFieldEnumID        PostScalarFieldEnum = "id"
	PostScalarFieldEnumPartnum   PostScalarFieldEnum = "partnum"
	PostScalarFieldEnumQuantity  PostScalarFieldEnum = "quantity"
	PostScalarFieldEnumCreatedAt PostScalarFieldEnum = "createdAt"
	PostScalarFieldEnumUpdatedAt PostScalarFieldEnum = "updatedAt"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type QueryMode string

const (
	QueryModeDefault     QueryMode = "default"
	QueryModeInsensitive QueryMode = "insensitive"
)

type NullsOrder string

const (
	NullsOrderFirst NullsOrder = "first"
	NullsOrderLast  NullsOrder = "last"
)

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound
var IsErrNotFound = types.IsErrNotFound

type ErrUniqueConstraint = types.ErrUniqueConstraint[prismaFields]

// IsErrUniqueConstraint returns on a unique constraint error or violation with error info
// Use as follows:
//
//	user, err := db.User.CreateOne(...).Exec(cxt)
//	if err != nil {
//		if info, err := db.IsErrUniqueConstraint(err); err != nil {
//			// Fields exists for Postgres and SQLite
//			log.Printf("unique constraint on the fields: %s", info.Fields)
//
//			// you can also compare it with generated field names:
//			if info.Fields[0] == db.User.Name.Field() {
//				// do something
//			}
//
//			// For MySQL, use the constraint key
//			log.Printf("unique constraint on the key: %s", info.Key)
//		}
//	}
func IsErrUniqueConstraint(err error) (*types.ErrUniqueConstraint[prismaFields], bool) {
	return types.CheckUniqueConstraint[prismaFields](err)
}

// --- template fields.gotpl ---
type prismaFields string

type postPrismaFields = prismaFields

const postFieldID postPrismaFields = "id"

const postFieldPartnum postPrismaFields = "partnum"

const postFieldQuantity postPrismaFields = "quantity"

const postFieldCreatedAt postPrismaFields = "createdAt"

const postFieldUpdatedAt postPrismaFields = "updatedAt"

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.Post = postMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	Post postMock
}

type postMock struct {
	mock *Mock
}

type PostMockExpectParam interface {
	ExtractQuery() builder.Query
	postModel()
}

func (m *postMock) Expect(query PostMockExpectParam) *postMockExec {
	return &postMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type postMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *postMockExec) Returns(v PostModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *postMockExec) ReturnsMany(v []PostModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *postMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// PostModel represents the Post model and is a wrapper for accessing fields and methods
type PostModel struct {
	InnerPost
	RelationsPost
}

// InnerPost holds the actual data
type InnerPost struct {
	ID        string    `json:"id"`
	Partnum   string    `json:"partnum"`
	Quantity  int       `json:"quantity"`
	CreatedAt *DateTime `json:"createdAt,omitempty"`
	UpdatedAt *DateTime `json:"updatedAt,omitempty"`
}

// RawPostModel is a struct for Post when used in raw queries
type RawPostModel struct {
	ID        RawString    `json:"id"`
	Partnum   RawString    `json:"partnum"`
	Quantity  RawInt       `json:"quantity"`
	CreatedAt *RawDateTime `json:"createdAt,omitempty"`
	UpdatedAt *RawDateTime `json:"updatedAt,omitempty"`
}

// RelationsPost holds the relation data separately
type RelationsPost struct {
}

func (r PostModel) CreatedAt() (value DateTime, ok bool) {
	if r.InnerPost.CreatedAt == nil {
		return value, false
	}
	return *r.InnerPost.CreatedAt, true
}

func (r PostModel) UpdatedAt() (value DateTime, ok bool) {
	if r.InnerPost.UpdatedAt == nil {
		return value, false
	}
	return *r.InnerPost.UpdatedAt, true
}

// --- template query.gotpl ---

// Post acts as a namespaces to access query methods for the Post model
var Post = postQuery{}

// postQuery exposes query functions for the post model
type postQuery struct {

	// ID
	//
	// @required
	ID postQueryIDString

	// Partnum
	//
	// @required
	Partnum postQueryPartnumString

	// Quantity
	//
	// @required
	Quantity postQueryQuantityInt

	// CreatedAt
	//
	// @optional
	CreatedAt postQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @optional
	UpdatedAt postQueryUpdatedAtDateTime
}

func (postQuery) Not(params ...PostWhereParam) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (postQuery) Or(params ...PostWhereParam) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (postQuery) And(params ...PostWhereParam) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type postQueryIDString struct{}

// Set the required value of ID
func (r postQueryIDString) Set(value string) postWithPrismaIDSetParam {

	return postWithPrismaIDSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r postQueryIDString) SetIfPresent(value *String) postWithPrismaIDSetParam {
	if value == nil {
		return postWithPrismaIDSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryIDString) Equals(value string) postWithPrismaIDEqualsUniqueParam {

	return postWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) EqualsIfPresent(value *string) postWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return postWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r postQueryIDString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r postQueryIDString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r postQueryIDString) In(value []string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) InIfPresent(value []string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.In(value)
}

func (r postQueryIDString) NotIn(value []string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) NotInIfPresent(value []string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.NotIn(value)
}

func (r postQueryIDString) Lt(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) LtIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Lt(*value)
}

func (r postQueryIDString) Lte(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) LteIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Lte(*value)
}

func (r postQueryIDString) Gt(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) GtIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Gt(*value)
}

func (r postQueryIDString) Gte(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) GteIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Gte(*value)
}

func (r postQueryIDString) Contains(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) ContainsIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Contains(*value)
}

func (r postQueryIDString) StartsWith(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) StartsWithIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r postQueryIDString) EndsWith(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) EndsWithIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r postQueryIDString) Mode(value QueryMode) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) ModeIfPresent(value *QueryMode) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Mode(*value)
}

func (r postQueryIDString) Not(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) NotIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryIDString) HasPrefix(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryIDString) HasPrefixIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryIDString) HasSuffix(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryIDString) HasSuffixIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryIDString) Field() postPrismaFields {
	return postFieldID
}

// base struct
type postQueryPartnumString struct{}

// Set the required value of Partnum
func (r postQueryPartnumString) Set(value string) postWithPrismaPartnumSetParam {

	return postWithPrismaPartnumSetParam{
		data: builder.Field{
			Name:  "partnum",
			Value: value,
		},
	}

}

// Set the optional value of Partnum dynamically
func (r postQueryPartnumString) SetIfPresent(value *String) postWithPrismaPartnumSetParam {
	if value == nil {
		return postWithPrismaPartnumSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryPartnumString) Equals(value string) postWithPrismaPartnumEqualsParam {

	return postWithPrismaPartnumEqualsParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPartnumString) EqualsIfPresent(value *string) postWithPrismaPartnumEqualsParam {
	if value == nil {
		return postWithPrismaPartnumEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryPartnumString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "partnum",
			Value: direction,
		},
	}
}

func (r postQueryPartnumString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "partnum",
			Value: cursor,
		},
	}
}

func (r postQueryPartnumString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPartnumString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryPartnumString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPartnumString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryPartnumString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPartnumString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryPartnumString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPartnumString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryPartnumString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPartnumString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryPartnumString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPartnumString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryPartnumString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPartnumString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryPartnumString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPartnumString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryPartnumString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPartnumString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryPartnumString) Mode(value QueryMode) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPartnumString) ModeIfPresent(value *QueryMode) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Mode(*value)
}

func (r postQueryPartnumString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPartnumString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryPartnumString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryPartnumString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryPartnumString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "partnum",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryPartnumString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryPartnumString) Field() postPrismaFields {
	return postFieldPartnum
}

// base struct
type postQueryQuantityInt struct{}

// Set the required value of Quantity
func (r postQueryQuantityInt) Set(value int) postSetParam {

	return postSetParam{
		data: builder.Field{
			Name:  "quantity",
			Value: value,
		},
	}

}

// Set the optional value of Quantity dynamically
func (r postQueryQuantityInt) SetIfPresent(value *Int) postSetParam {
	if value == nil {
		return postSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Quantity
func (r postQueryQuantityInt) Increment(value int) postSetParam {
	return postSetParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryQuantityInt) IncrementIfPresent(value *int) postSetParam {
	if value == nil {
		return postSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Quantity
func (r postQueryQuantityInt) Decrement(value int) postSetParam {
	return postSetParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryQuantityInt) DecrementIfPresent(value *int) postSetParam {
	if value == nil {
		return postSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Quantity
func (r postQueryQuantityInt) Multiply(value int) postSetParam {
	return postSetParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryQuantityInt) MultiplyIfPresent(value *int) postSetParam {
	if value == nil {
		return postSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Quantity
func (r postQueryQuantityInt) Divide(value int) postSetParam {
	return postSetParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryQuantityInt) DivideIfPresent(value *int) postSetParam {
	if value == nil {
		return postSetParam{}
	}
	return r.Divide(*value)
}

func (r postQueryQuantityInt) Equals(value int) postWithPrismaQuantityEqualsParam {

	return postWithPrismaQuantityEqualsParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryQuantityInt) EqualsIfPresent(value *int) postWithPrismaQuantityEqualsParam {
	if value == nil {
		return postWithPrismaQuantityEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryQuantityInt) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "quantity",
			Value: direction,
		},
	}
}

func (r postQueryQuantityInt) Cursor(cursor int) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "quantity",
			Value: cursor,
		},
	}
}

func (r postQueryQuantityInt) In(value []int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryQuantityInt) InIfPresent(value []int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryQuantityInt) NotIn(value []int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryQuantityInt) NotInIfPresent(value []int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryQuantityInt) Lt(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryQuantityInt) LtIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryQuantityInt) Lte(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryQuantityInt) LteIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryQuantityInt) Gt(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryQuantityInt) GtIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryQuantityInt) Gte(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryQuantityInt) GteIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryQuantityInt) Not(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryQuantityInt) NotIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r postQueryQuantityInt) LT(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r postQueryQuantityInt) LTIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r postQueryQuantityInt) LTE(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r postQueryQuantityInt) LTEIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r postQueryQuantityInt) GT(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r postQueryQuantityInt) GTIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r postQueryQuantityInt) GTE(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r postQueryQuantityInt) GTEIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.GTE(*value)
}

func (r postQueryQuantityInt) Field() postPrismaFields {
	return postFieldQuantity
}

// base struct
type postQueryCreatedAtDateTime struct{}

// Set the optional value of CreatedAt
func (r postQueryCreatedAtDateTime) Set(value DateTime) postSetParam {

	return postSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r postQueryCreatedAtDateTime) SetIfPresent(value *DateTime) postSetParam {
	if value == nil {
		return postSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of CreatedAt dynamically
func (r postQueryCreatedAtDateTime) SetOptional(value *DateTime) postSetParam {
	if value == nil {

		var v *DateTime
		return postSetParam{
			data: builder.Field{
				Name:  "createdAt",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r postQueryCreatedAtDateTime) Equals(value DateTime) postWithPrismaCreatedAtEqualsParam {

	return postWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) postWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return postWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryCreatedAtDateTime) EqualsOptional(value *DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) IsNull() postDefaultParam {
	var str *string = nil
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r postQueryCreatedAtDateTime) Cursor(cursor DateTime) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r postQueryCreatedAtDateTime) In(value []DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) InIfPresent(value []DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryCreatedAtDateTime) NotIn(value []DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryCreatedAtDateTime) Lt(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) LtIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryCreatedAtDateTime) Lte(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) LteIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryCreatedAtDateTime) Gt(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) GtIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryCreatedAtDateTime) Gte(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) GteIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryCreatedAtDateTime) Not(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) NotIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r postQueryCreatedAtDateTime) Before(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r postQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r postQueryCreatedAtDateTime) After(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r postQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r postQueryCreatedAtDateTime) BeforeEquals(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r postQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r postQueryCreatedAtDateTime) AfterEquals(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r postQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r postQueryCreatedAtDateTime) Field() postPrismaFields {
	return postFieldCreatedAt
}

// base struct
type postQueryUpdatedAtDateTime struct{}

// Set the optional value of UpdatedAt
func (r postQueryUpdatedAtDateTime) Set(value DateTime) postSetParam {

	return postSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r postQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) postSetParam {
	if value == nil {
		return postSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of UpdatedAt dynamically
func (r postQueryUpdatedAtDateTime) SetOptional(value *DateTime) postSetParam {
	if value == nil {

		var v *DateTime
		return postSetParam{
			data: builder.Field{
				Name:  "updatedAt",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r postQueryUpdatedAtDateTime) Equals(value DateTime) postWithPrismaUpdatedAtEqualsParam {

	return postWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) postWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return postWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryUpdatedAtDateTime) EqualsOptional(value *DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) IsNull() postDefaultParam {
	var str *string = nil
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r postQueryUpdatedAtDateTime) Cursor(cursor DateTime) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r postQueryUpdatedAtDateTime) In(value []DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) InIfPresent(value []DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryUpdatedAtDateTime) NotIn(value []DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryUpdatedAtDateTime) Lt(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryUpdatedAtDateTime) Lte(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryUpdatedAtDateTime) Gt(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryUpdatedAtDateTime) Gte(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryUpdatedAtDateTime) Not(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r postQueryUpdatedAtDateTime) Before(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r postQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r postQueryUpdatedAtDateTime) After(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r postQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r postQueryUpdatedAtDateTime) BeforeEquals(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r postQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r postQueryUpdatedAtDateTime) AfterEquals(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r postQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r postQueryUpdatedAtDateTime) Field() postPrismaFields {
	return postFieldUpdatedAt
}

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type postActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var postOutput = []builder.Output{
	{Name: "id"},
	{Name: "partnum"},
	{Name: "quantity"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type PostRelationWith interface {
	getQuery() builder.Query
	with()
	postRelation()
}

type PostWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
}

type postDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p postDefaultParam) field() builder.Field {
	return p.data
}

func (p postDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p postDefaultParam) postModel() {}

type PostOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
}

type postOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p postOrderByParam) field() builder.Field {
	return p.data
}

func (p postOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p postOrderByParam) postModel() {}

type PostCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	isCursor()
}

type postCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p postCursorParam) field() builder.Field {
	return p.data
}

func (p postCursorParam) isCursor() {}

func (p postCursorParam) getQuery() builder.Query {
	return p.query
}

func (p postCursorParam) postModel() {}

type PostParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	postModel()
}

type postParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p postParamUnique) postModel() {}

func (postParamUnique) unique() {}

func (p postParamUnique) field() builder.Field {
	return p.data
}

func (p postParamUnique) getQuery() builder.Query {
	return p.query
}

type PostEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
}

type postEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postEqualsParam) postModel() {}

func (postEqualsParam) equals() {}

func (p postEqualsParam) field() builder.Field {
	return p.data
}

func (p postEqualsParam) getQuery() builder.Query {
	return p.query
}

type PostEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	postModel()
}

type postEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postEqualsUniqueParam) postModel() {}

func (postEqualsUniqueParam) unique() {}
func (postEqualsUniqueParam) equals() {}

func (p postEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type PostSetParam interface {
	field() builder.Field
	settable()
	postModel()
}

type postSetParam struct {
	data builder.Field
}

func (postSetParam) settable() {}

func (p postSetParam) field() builder.Field {
	return p.data
}

func (p postSetParam) postModel() {}

type PostWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	idField()
}

type PostWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	idField()
}

type postWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaIDSetParam) postModel() {}

func (p postWithPrismaIDSetParam) idField() {}

type PostWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	idField()
}

type postWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaIDEqualsParam) postModel() {}

func (p postWithPrismaIDEqualsParam) idField() {}

func (postWithPrismaIDSetParam) settable()  {}
func (postWithPrismaIDEqualsParam) equals() {}

type postWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaIDEqualsUniqueParam) postModel() {}
func (p postWithPrismaIDEqualsUniqueParam) idField()   {}

func (postWithPrismaIDEqualsUniqueParam) unique() {}
func (postWithPrismaIDEqualsUniqueParam) equals() {}

type PostWithPrismaPartnumEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	partnumField()
}

type PostWithPrismaPartnumSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	partnumField()
}

type postWithPrismaPartnumSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaPartnumSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaPartnumSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaPartnumSetParam) postModel() {}

func (p postWithPrismaPartnumSetParam) partnumField() {}

type PostWithPrismaPartnumWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	partnumField()
}

type postWithPrismaPartnumEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaPartnumEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaPartnumEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaPartnumEqualsParam) postModel() {}

func (p postWithPrismaPartnumEqualsParam) partnumField() {}

func (postWithPrismaPartnumSetParam) settable()  {}
func (postWithPrismaPartnumEqualsParam) equals() {}

type postWithPrismaPartnumEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaPartnumEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaPartnumEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaPartnumEqualsUniqueParam) postModel()    {}
func (p postWithPrismaPartnumEqualsUniqueParam) partnumField() {}

func (postWithPrismaPartnumEqualsUniqueParam) unique() {}
func (postWithPrismaPartnumEqualsUniqueParam) equals() {}

type PostWithPrismaQuantityEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	quantityField()
}

type PostWithPrismaQuantitySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	quantityField()
}

type postWithPrismaQuantitySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaQuantitySetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaQuantitySetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaQuantitySetParam) postModel() {}

func (p postWithPrismaQuantitySetParam) quantityField() {}

type PostWithPrismaQuantityWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	quantityField()
}

type postWithPrismaQuantityEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaQuantityEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaQuantityEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaQuantityEqualsParam) postModel() {}

func (p postWithPrismaQuantityEqualsParam) quantityField() {}

func (postWithPrismaQuantitySetParam) settable()  {}
func (postWithPrismaQuantityEqualsParam) equals() {}

type postWithPrismaQuantityEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaQuantityEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaQuantityEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaQuantityEqualsUniqueParam) postModel()     {}
func (p postWithPrismaQuantityEqualsUniqueParam) quantityField() {}

func (postWithPrismaQuantityEqualsUniqueParam) unique() {}
func (postWithPrismaQuantityEqualsUniqueParam) equals() {}

type PostWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	createdAtField()
}

type PostWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	createdAtField()
}

type postWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCreatedAtSetParam) postModel() {}

func (p postWithPrismaCreatedAtSetParam) createdAtField() {}

type PostWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	createdAtField()
}

type postWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCreatedAtEqualsParam) postModel() {}

func (p postWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (postWithPrismaCreatedAtSetParam) settable()  {}
func (postWithPrismaCreatedAtEqualsParam) equals() {}

type postWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCreatedAtEqualsUniqueParam) postModel()      {}
func (p postWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (postWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (postWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type PostWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	updatedAtField()
}

type PostWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	updatedAtField()
}

type postWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaUpdatedAtSetParam) postModel() {}

func (p postWithPrismaUpdatedAtSetParam) updatedAtField() {}

type PostWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	updatedAtField()
}

type postWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaUpdatedAtEqualsParam) postModel() {}

func (p postWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (postWithPrismaUpdatedAtSetParam) settable()  {}
func (postWithPrismaUpdatedAtEqualsParam) equals() {}

type postWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaUpdatedAtEqualsUniqueParam) postModel()      {}
func (p postWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (postWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (postWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

// --- template create.gotpl ---

// Creates a single post.
func (r postActions) CreateOne(
	_id PostWithPrismaIDSetParam,
	_partnum PostWithPrismaPartnumSetParam,

	optional ...PostSetParam,
) postCreateOne {
	var v postCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Post"
	v.query.Outputs = postOutput

	var fields []builder.Field

	fields = append(fields, _id.field())
	fields = append(fields, _partnum.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r postCreateOne) With(params ...PostRelationWith) postCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type postCreateOne struct {
	query builder.Query
}

func (p postCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p postCreateOne) postModel() {}

func (r postCreateOne) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postCreateOne) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type postFindUnique struct {
	query builder.Query
}

func (r postFindUnique) getQuery() builder.Query {
	return r.query
}

func (r postFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postFindUnique) with()         {}
func (r postFindUnique) postModel()    {}
func (r postFindUnique) postRelation() {}

func (r postActions) FindUnique(
	params PostEqualsUniqueWhereParam,
) postFindUnique {
	var v postFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Post"
	v.query.Outputs = postOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r postFindUnique) With(params ...PostRelationWith) postFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postFindUnique) Select(params ...postPrismaFields) postFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindUnique) Omit(params ...postPrismaFields) postFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindUnique) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postFindUnique) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postFindUnique) Update(params ...PostSetParam) postUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"

	var v postUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postUpdateUnique struct {
	query builder.Query
}

func (r postUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postUpdateUnique) postModel() {}

func (r postUpdateUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postUpdateUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postFindUnique) Delete() postDeleteUnique {
	var v postDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"

	return v
}

type postDeleteUnique struct {
	query builder.Query
}

func (r postDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p postDeleteUnique) postModel() {}

func (r postDeleteUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postDeleteUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postFindFirst struct {
	query builder.Query
}

func (r postFindFirst) getQuery() builder.Query {
	return r.query
}

func (r postFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r postFindFirst) with()         {}
func (r postFindFirst) postModel()    {}
func (r postFindFirst) postRelation() {}

func (r postActions) FindFirst(
	params ...PostWhereParam,
) postFindFirst {
	var v postFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Post"
	v.query.Outputs = postOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r postFindFirst) With(params ...PostRelationWith) postFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postFindFirst) Select(params ...postPrismaFields) postFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindFirst) Omit(params ...postPrismaFields) postFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindFirst) OrderBy(params ...PostOrderByParam) postFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postFindFirst) Skip(count int) postFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postFindFirst) Take(count int) postFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postFindFirst) Cursor(cursor PostCursorParam) postFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postFindFirst) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postFindFirst) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type postFindMany struct {
	query builder.Query
}

func (r postFindMany) getQuery() builder.Query {
	return r.query
}

func (r postFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postFindMany) with()         {}
func (r postFindMany) postModel()    {}
func (r postFindMany) postRelation() {}

func (r postActions) FindMany(
	params ...PostWhereParam,
) postFindMany {
	var v postFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Post"
	v.query.Outputs = postOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r postFindMany) With(params ...PostRelationWith) postFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postFindMany) Select(params ...postPrismaFields) postFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindMany) Omit(params ...postPrismaFields) postFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindMany) OrderBy(params ...PostOrderByParam) postFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postFindMany) Skip(count int) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postFindMany) Take(count int) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postFindMany) Cursor(cursor PostCursorParam) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v []PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postFindMany) ExecInner(ctx context.Context) (
	[]InnerPost,
	error,
) {
	var v []InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postFindMany) Update(params ...PostSetParam) postUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"

	r.query.Outputs = countOutput

	var v postUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postUpdateMany struct {
	query builder.Query
}

func (r postUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postUpdateMany) postModel() {}

func (r postUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postUpdateMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postFindMany) Delete() postDeleteMany {
	var v postDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"

	v.query.Outputs = countOutput

	return v
}

type postDeleteMany struct {
	query builder.Query
}

func (r postDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p postDeleteMany) postModel() {}

func (r postDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postDeleteMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func newPostUniqueTxResult() PostUniqueTxResult {
	return PostUniqueTxResult{
		result: &transaction.Result{},
	}
}

type PostUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p PostUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p PostUniqueTxResult) IsTx() {}

func (r PostUniqueTxResult) Result() (v *PostModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newPostManyTxResult() PostManyTxResult {
	return PostManyTxResult{
		result: &transaction.Result{},
	}
}

type PostManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p PostManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p PostManyTxResult) IsTx() {}

func (r PostManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template upsert.gotpl ---

type postUpsertOne struct {
	query builder.Query
}

func (r postUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r postUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r postUpsertOne) with()         {}
func (r postUpsertOne) postModel()    {}
func (r postUpsertOne) postRelation() {}

func (r postActions) UpsertOne(
	params PostEqualsUniqueWhereParam,
) postUpsertOne {
	var v postUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Post"
	v.query.Outputs = postOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r postUpsertOne) Create(

	_id PostWithPrismaIDSetParam,
	_partnum PostWithPrismaPartnumSetParam,

	optional ...PostSetParam,
) postUpsertOne {
	var v postUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _id.field())
	fields = append(fields, _partnum.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r postUpsertOne) Update(
	params ...PostSetParam,
) postUpsertOne {
	var v postUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r postUpsertOne) CreateOrUpdate(

	_id PostWithPrismaIDSetParam,
	_partnum PostWithPrismaPartnumSetParam,

	optional ...PostSetParam,
) postUpsertOne {
	var v postUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _id.field())
	fields = append(fields, _partnum.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r postUpsertOne) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postUpsertOne) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template raw.gotpl ---

type postAggregateRaw struct {
	query builder.Query
}

func (r postAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r postAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r postAggregateRaw) with()         {}
func (r postAggregateRaw) postModel()    {}
func (r postAggregateRaw) postRelation() {}

func (r postActions) FindRaw(filter interface{}, options ...interface{}) postAggregateRaw {
	var v postAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Post"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r postActions) AggregateRaw(pipeline []interface{}, options ...interface{}) postAggregateRaw {
	var v postAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Post"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r postAggregateRaw) Exec(ctx context.Context) ([]PostModel, error) {
	var v []PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r postAggregateRaw) ExecInner(ctx context.Context) ([]InnerPost, error) {
	var v []InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}
